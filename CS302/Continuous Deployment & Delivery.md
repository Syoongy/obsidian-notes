# Continuous Delivery
Producing _deliverable software_ in _short cycles_. Treating _every change_ to code as _releasable_.
Releases **must be triggered** by a developer.
Automated processes to _deploy code_ to any environment
## Terminology
- ### Release
	- #### Noun
		- A version of software intended for use outside the dev team; Could be internal (e.g. for QA or demo) or external
		- Something that can be shipped to the customer
		- Source code
		- Binaries/ executables
		- release notes
		- Docker Image
	- #### Verb
		- Act of making a release version available (e.g. Releasing new functionality to customers (business value))
		- "Release a release"
- ### Deploy
	- Installing/running a version of software; This version may/may not be a release
## Who should push the button?
Should it be ops or devs? From the 2013 state of DevOps report, there were no statistically significant difference in change between deployments between ops or devs.
## Implementing it
Requires a strong foundation in CI (Test suite should continually grow with features and bug fixes)
Use a CI/CD pipeline to ensure code is in a deployable state
![[week05_cd_01.png]]
![[week05_cd_02.png]]
## Release Versioning
Traditionally, _semantic versioning_ is used for releases. Assume we are on v1.3.4
A patch (bug fix) -> v1.3.5
A minor update (new feature) -> v1.4.0
A major update (not backward compatible) -> v2.0.0

This does not make sense when deploying several times a day and instead dynamic versioning is applied using pipeline variables (e.g. v1.3.4.c4efdc1979, v1.3.c4efdc1979, or even just c4efdc1979)
# Continuous Deployment
Automatically deploy changes that pass the pipeline.

Previously, we used to send apps to IT ops where the onus of responsibility is passed to them. These were then deployed on heavyweight on-premise servers (WebLogic/WebSphere). These were loved and cared for like pets.

In more recent times, we now deploy on lightweight and short-lived environments as they are easier to discord/recreate than re-configure
![[week05_cd_03.png]]![[week05_cd_04.png]]
## Patterns
### Serverless Deployment
- Platforms (e.g. AWS Lambda) abstract away from computing infrastructure and resources.
	- Upload your code and run it
	- Scaling handled automatically
- Under the hood - code is run in containers
- Invoking microservices that are implemented as lambda functions:
	- Events generated by AWS services
	- HTTP requests (routed via an AWS API Gateway)
	- Scheduled invocations (cron-like)
![[week05_cd_05.png]]
### Service as a Container
- Packaging service as an image and deploy each service as a container
- From the perspective of the containerised service:
	- Own IP address (No port conflicts)
	- Own root filesystem
- Can Specify CPU, memory and I/O resources
	- "Lower level" than serverless pattern
![[week05_cd_06.png]]
- Orchestration engines (e.g. ECS, K8) try to manage resources, scheduling and discovery in production
![[week05_cd_07.png]]
#### AWS ECS
![[week05_cd_08.png]]
##### Concepts
- **Task Definition** - Describes the container(s) that forms your app
	- For microservices  - One image + resource constraints
- **Task** - A running instantiation of a task definition
- **_Service_** - Runs/maintains a specified number of tasks
	- One ECS _Service_ can run multiple instances of a container
- **Cluster** - A logical grouping of tasks and services
	- EC2 instance(s) are registered to the cluster for running tasks
##### Continuous Deployment
Eliminates human intervention from the deployment process
![[week05_cd_10.png]]
###### Patterns
![[week05_cd_11.png]]
![[week05_cd_12.png]]
#### Controlling Releases
We use Feature Flags to do this!
Application-based release patterns are implemented via these flags
- Wrapping app logic/ UI elements with a conditional statement
- Enabled/Disabled based on a configuration setting
This is to ensure easy rollback, gracefully degrading service, resilience in microservice deployments
